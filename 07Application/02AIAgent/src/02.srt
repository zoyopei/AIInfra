1
00:00:00,000 --> 00:00:01,766
内容/录制:Z0MI酱，视频后期 /字幕:梁嘉铭

2
00:00:01,766 --> 00:00:02,966
hello大家好

3
00:00:02,966 --> 00:00:04,466
我是那个刚放完长假

4
00:00:04,500 --> 00:00:07,133
又想继续放假的zomi

5
00:00:07,133 --> 00:00:08,433
假假不休

6
00:00:10,100 --> 00:00:11,533
那在上一期视频里面

7
00:00:11,533 --> 00:00:14,500
我们讲了MCP的一个基本的内容

8
00:00:14,500 --> 00:00:15,933
和MCP到底是什么

9
00:00:15,933 --> 00:00:17,766
今天我们重点来打开一下

10
00:00:17,766 --> 00:00:19,900
MCP的一个核心原理

11
00:00:19,933 --> 00:00:21,100
看一下它的架构

12
00:00:21,100 --> 00:00:22,200
看一下对应的代码

13
00:00:22,200 --> 00:00:25,800
看一下MCP的server是怎么去实现

14
00:00:25,800 --> 00:00:28,866
所以说这一期我们就有三个内容

15
00:00:28,900 --> 00:00:29,300
第一个

16
00:00:29,300 --> 00:00:31,533
就是看一下MCP的核心的架构

17
00:00:31,533 --> 00:00:34,000
它主要是cs架构

18
00:00:34,000 --> 00:00:37,066
也有对应的client and server相关的架构

19
00:00:37,100 --> 00:00:39,000
然后看一下它的一个设计理念

20
00:00:39,000 --> 00:00:40,033
有了架构之后

21
00:00:40,033 --> 00:00:44,366
里面的细节是由设计理念去牵引

22
00:00:44,366 --> 00:00:46,966
不好意思原谅我的塑料普通话

23
00:00:47,000 --> 00:00:47,800
那到了第三个

24
00:00:47,800 --> 00:00:49,200
我们看一下模型

25
00:00:49,200 --> 00:00:51,400
就最核心的一个大模型

26
00:00:51,400 --> 00:00:54,166
AI怎么去通过MCP

27
00:00:54,166 --> 00:00:56,600
去确定具体的工具的使用

28
00:00:56,600 --> 00:00:57,966
那这里面第三个内容

29
00:00:57,966 --> 00:00:58,900
也就是最核心

30
00:00:58,933 --> 00:01:01,400
我们真正的会打开一些代码层面

31
00:01:01,400 --> 00:01:02,900
去看一下大模型

32
00:01:02,933 --> 00:01:05,833
怎么通过MCP工具调用起来

33
00:01:05,833 --> 00:01:06,700
真正

34
00:01:06,733 --> 00:01:10,833
就变成AI Agent的最初的雏形了

35
00:01:13,000 --> 00:01:14,466
现在我们时不宜迟

36
00:01:14,500 --> 00:01:15,966
马上来到了第一个内容

37
00:01:15,966 --> 00:01:19,600
看一下整个MCP的整体的架构

38
00:01:19,600 --> 00:01:20,233
那首先

39
00:01:20,233 --> 00:01:22,966
很多人说MCP它是一个host跟client

40
00:01:22,966 --> 00:01:24,166
server相关的架构

41
00:01:24,166 --> 00:01:25,866
但是作为一个计算机专业的人

42
00:01:25,900 --> 00:01:26,533
告诉你们

43
00:01:26,533 --> 00:01:27,400
实际上

44
00:01:27,400 --> 00:01:30,500
整个MCP采用的是一个CS的架构

45
00:01:30,533 --> 00:01:31,600
因为CS的架构

46
00:01:31,600 --> 00:01:34,633
是整个计算机里面非常经典的一个架构

47
00:01:34,700 --> 00:01:37,333
首先这里面的c就指client

48
00:01:37,566 --> 00:01:39,833
s主要是指server端

49
00:01:39,833 --> 00:01:41,033
那client和server端

50
00:01:41,033 --> 00:01:41,600
一个服务端

51
00:01:41,600 --> 00:01:44,400
一个客户端是一对一的配比

52
00:01:44,400 --> 00:01:46,633
中间通过一个transport layer

53
00:01:46,633 --> 00:01:47,866
也就是中间的传输层

54
00:01:47,900 --> 00:01:50,000
进行一个互相的交互

55
00:01:50,000 --> 00:01:53,000
而在整体的多个client结合起来

56
00:01:53,000 --> 00:01:54,233
可以变成一个host

57
00:01:54,233 --> 00:01:55,166
那所谓的host

58
00:01:55,166 --> 00:01:56,966
实际上不是多个client结合起来

59
00:01:56,966 --> 00:01:58,300
而是一个host

60
00:01:58,333 --> 00:01:59,966
我们具体的一个应用了

61
00:01:59,966 --> 00:02:01,833
它可以承载很多个client

62
00:02:01,833 --> 00:02:04,466
client之间可以通过多个transport layer

63
00:02:04,500 --> 00:02:07,566
来去调取对应的服务

64
00:02:08,166 --> 00:02:09,066
那我们现在来看看

65
00:02:09,100 --> 00:02:10,900
整个大的架构里面

66
00:02:10,900 --> 00:02:12,400
就是一个CS架构了

67
00:02:12,400 --> 00:02:13,666
由哪几块内容组成

68
00:02:13,700 --> 00:02:16,200
首先我们刚才讲到的一个host

69
00:02:16,233 --> 00:02:18,066
host主要是指大模型

70
00:02:18,100 --> 00:02:19,033
具体的应用了

71
00:02:19,033 --> 00:02:22,033
例如claude Desktop是我们相关的应用

72
00:02:22,033 --> 00:02:22,700
那第二个

73
00:02:22,733 --> 00:02:23,966
就由client

74
00:02:24,600 --> 00:02:26,866
client主要是维持一对一的链接

75
00:02:26,900 --> 00:02:29,400
跟server进行一个配比

76
00:02:29,400 --> 00:02:30,500
提供一个host

77
00:02:30,533 --> 00:02:32,800
一个APP的相关的一个接口

78
00:02:32,900 --> 00:02:34,700
对应的就是server

79
00:02:34,700 --> 00:02:36,533
server就提供一些上下文的工具

80
00:02:36,533 --> 00:02:38,366
还有prompt了给client

81
00:02:38,533 --> 00:02:40,766
真正很多的应用开发者

82
00:02:40,766 --> 00:02:42,500
主要是提供对应的MCP

83
00:02:42,533 --> 00:02:43,600
server就可以了

84
00:02:43,600 --> 00:02:45,666
我们将会在下一小节内容里面

85
00:02:45,700 --> 00:02:46,600
打开代码

86
00:02:46,600 --> 00:02:48,766
跟大家一起去重点的看一看

87
00:02:48,766 --> 00:02:51,766
所以说整体来说它有4个模块

88
00:02:51,766 --> 00:02:52,566
4个内容

89
00:02:52,633 --> 00:02:54,700
采用CS的架构

90
00:02:54,733 --> 00:02:56,033
那第一个内容就是host

91
00:02:56,033 --> 00:02:56,566
第二个内容

92
00:02:56,566 --> 00:02:57,266
就是client

93
00:02:57,300 --> 00:02:58,400
还有transport layer

94
00:02:58,400 --> 00:03:02,800
还有对应的serverd 4块主要的内容

95
00:03:02,800 --> 00:03:03,600
我们现在

96
00:03:03,600 --> 00:03:04,166
逐个

97
00:03:04,166 --> 00:03:08,100
或者更加详细的打开右边的这个图了

98
00:03:08,133 --> 00:03:08,900
那这个图

99
00:03:08,900 --> 00:03:11,566
就是官方给出的整体的一个架构图

100
00:03:11,566 --> 00:03:13,300
采用CS的模式

101
00:03:13,333 --> 00:03:14,300
那整个MCP

102
00:03:14,300 --> 00:03:15,400
我们看到host

103
00:03:15,400 --> 00:03:16,200
client server

104
00:03:16,200 --> 00:03:16,866
我们现在

105
00:03:16,900 --> 00:03:18,300
以一个实际的场景

106
00:03:18,300 --> 00:03:20,333
来去理解这些组件之间

107
00:03:20,333 --> 00:03:23,500
这三个组件之间是怎么去协同

108
00:03:23,566 --> 00:03:23,966
假设

109
00:03:23,966 --> 00:03:26,866
我们现在正在使用一个claude Desktop

110
00:03:27,233 --> 00:03:28,366
也就是claude Desktop

111
00:03:28,366 --> 00:03:30,000
作为一个host

112
00:03:30,033 --> 00:03:32,700
来去询问我桌面上有哪些文件

113
00:03:32,733 --> 00:03:33,600
那这个时候

114
00:03:33,600 --> 00:03:35,800
host也就是claude Desktop

115
00:03:35,933 --> 00:03:39,533
就会负责接收一个提问的问题

116
00:03:39,533 --> 00:03:40,400
然后

117
00:03:40,400 --> 00:03:43,000
跟claude这个大模型进行一些交互

118
00:03:43,000 --> 00:03:43,700
那这个时候

119
00:03:43,733 --> 00:03:45,366
因为整个MCP的host里面

120
00:03:45,366 --> 00:03:46,800
有很多个client

121
00:03:46,933 --> 00:03:48,166
那大模型

122
00:03:48,166 --> 00:03:49,000
决定要访问

123
00:03:49,000 --> 00:03:51,100
一个文件系统的时候

124
00:03:51,133 --> 00:03:53,633
那host里面的MCP的client

125
00:03:53,633 --> 00:03:56,033
就其中一个c就会被激活

126
00:03:56,033 --> 00:03:56,700
这个client

127
00:03:56,733 --> 00:03:59,900
就负责跟适当的一个MCP的server

128
00:03:59,900 --> 00:04:01,333
进行一个连接

129
00:04:01,333 --> 00:04:03,300
那这个连接是双向

130
00:04:03,333 --> 00:04:04,100
那接着

131
00:04:04,100 --> 00:04:05,033
我们第三步

132
00:04:05,033 --> 00:04:06,566
就是server端了

133
00:04:06,566 --> 00:04:07,633
在这个例子里面

134
00:04:07,633 --> 00:04:09,433
文件系统

135
00:04:09,433 --> 00:04:12,766
文件系统的MCP的server就会被调用了

136
00:04:12,766 --> 00:04:15,500
所以我们这里面就会调用local resource

137
00:04:15,766 --> 00:04:19,166
然后去执行实际的文件的操作和扫描

138
00:04:19,166 --> 00:04:20,500
访问一个目录

139
00:04:20,533 --> 00:04:23,433
也就是我们上一期期视频讲到

140
00:04:23,433 --> 00:04:24,233
小的demo

141
00:04:24,233 --> 00:04:27,033
并且返回找回到的一个文件

142
00:04:27,033 --> 00:04:28,766
因此整体流程

143
00:04:28,766 --> 00:04:30,800
就是我提出一个问题

144
00:04:30,800 --> 00:04:32,233
然后claude Desktop

145
00:04:32,233 --> 00:04:33,900
就去接收问题

146
00:04:33,933 --> 00:04:35,766
然后去调用大模型

147
00:04:35,766 --> 00:04:38,466
大模型就发现我需要文件信息

148
00:04:38,500 --> 00:04:38,900
于是

149
00:04:38,900 --> 00:04:42,833
就触发整个MCP的一个client的一个执行

150
00:04:42,833 --> 00:04:43,966
client执行完之后

151
00:04:43,966 --> 00:04:46,433
就会跟MCP的server

152
00:04:46,433 --> 00:04:49,033
就对应的server进行一个操作

153
00:04:49,033 --> 00:04:50,833
然后调起我们本地的资源

154
00:04:50,833 --> 00:04:52,300
调起本地资源之后

155
00:04:52,333 --> 00:04:53,833
再一层层的返回

156
00:04:53,833 --> 00:04:55,800
给给到claude Desktop

157
00:04:55,800 --> 00:04:57,866
这种整体的架构的设计

158
00:04:57,900 --> 00:04:59,800
使得一些大模型

159
00:04:59,800 --> 00:05:02,466
AI的大模型可以在不同的场景下

160
00:05:02,500 --> 00:05:04,800
灵活的调用各种各样的工具

161
00:05:04,800 --> 00:05:05,900
和数据集

162
00:05:05,933 --> 00:05:07,400
或者数据的内容

163
00:05:07,400 --> 00:05:08,600
开发者

164
00:05:08,600 --> 00:05:12,266
只需要专注于开发对应的server

165
00:05:12,300 --> 00:05:13,200
就可以了

166
00:05:13,200 --> 00:05:14,500
不需要关心host

167
00:05:14,533 --> 00:05:16,766
跟client的一个实现的细节

168
00:05:16,766 --> 00:05:18,433
反正很多应用的开发者

169
00:05:18,433 --> 00:05:21,700
就实现各种各样的MCP的server就行了

170
00:05:21,733 --> 00:05:24,166
我们将会在下下个内容

171
00:05:24,166 --> 00:05:25,633
跟大家一起去实现

172
00:05:25,633 --> 00:05:28,200
或者去看一下server的一个实现的Demo

173
00:05:28,200 --> 00:05:29,200
代码

174
00:05:30,400 --> 00:05:31,633
简单的消化一下

175
00:05:31,633 --> 00:05:33,666
我们现在来到了第二个内容了

176
00:05:33,700 --> 00:05:38,233
也就是核心的设计理念了call principle

177
00:05:38,233 --> 00:05:41,066
那我们这个图其实之前已经看到过了

178
00:05:41,100 --> 00:05:43,200
大家都说整个MCP

179
00:05:43,200 --> 00:05:46,433
主要是类似于一个AI的USB port

180
00:05:46,433 --> 00:05:48,600
其实举太多的例子了

181
00:05:48,600 --> 00:05:49,533
太扯淡了

182
00:05:49,566 --> 00:05:51,533
说白了就是我们以前

183
00:05:51,533 --> 00:05:53,133
没有MCP的时候

184
00:05:53,133 --> 00:05:55,300
应用要对接不同的大模型

185
00:05:55,300 --> 00:05:57,100
要写很多的functions call

186
00:05:57,100 --> 00:05:59,033
非常的浪费时间

187
00:05:59,033 --> 00:06:00,700
那为了解决这个问题

188
00:06:00,733 --> 00:06:01,433
我们现在

189
00:06:01,433 --> 00:06:03,200
就提出了一个MCP Protocol

190
00:06:03,200 --> 00:06:05,266
也就是中间藏过了中间件

191
00:06:05,333 --> 00:06:07,333
或者中间的一个协议了

192
00:06:07,333 --> 00:06:08,766
所有的大模型

193
00:06:08,766 --> 00:06:10,900
都能够对接到统一的标准

194
00:06:10,933 --> 00:06:12,166
包括应用也是

195
00:06:12,166 --> 00:06:12,600
这样的话

196
00:06:12,600 --> 00:06:14,100
会加速应用

197
00:06:14,133 --> 00:06:15,733
跟大模型的一个结合

198
00:06:15,733 --> 00:06:18,700
但是这个MCP的Protocol

199
00:06:18,700 --> 00:06:19,966
就MCP的协议

200
00:06:19,966 --> 00:06:22,766
最核心的就是加快我们AI agent

201
00:06:22,766 --> 00:06:23,400
或者大模型

202
00:06:23,400 --> 00:06:25,233
跟工具的一个连接方式

203
00:06:25,233 --> 00:06:28,100
并没有改变一个AI agent的本质

204
00:06:28,133 --> 00:06:29,566
所以说我们之前

205
00:06:29,566 --> 00:06:31,066
不管是怎么说也好

206
00:06:31,100 --> 00:06:33,300
反正我觉得都是类似

207
00:06:34,633 --> 00:06:36,866
既然有了MCP Protocol之后

208
00:06:36,900 --> 00:06:37,500
我们看一下

209
00:06:37,500 --> 00:06:38,766
为了解决这个问题

210
00:06:38,766 --> 00:06:40,233
就是为了让大模型

211
00:06:40,233 --> 00:06:41,966
跟应用结合在一起

212
00:06:41,966 --> 00:06:44,100
首先要提供非常标准化

213
00:06:44,133 --> 00:06:46,300
也就是structured context management

214
00:06:46,300 --> 00:06:48,600
非常标准化的上下文的管理

215
00:06:48,600 --> 00:06:50,666
上下文的内容和资源

216
00:06:50,800 --> 00:06:53,966
因为大模型能够接入的是一个token

217
00:06:54,033 --> 00:06:56,000
token

218
00:06:56,000 --> 00:06:58,200
也就是我们对应的词元

219
00:06:58,200 --> 00:06:59,833
我们大模型的输入是token

220
00:06:59,833 --> 00:07:01,633
大模型的输出是token

221
00:07:01,666 --> 00:07:03,000
那为了解决这个问题

222
00:07:03,000 --> 00:07:06,433
在这里面我们叫做context上下文

223
00:07:06,433 --> 00:07:09,033
那其实我们不像传统的一些

224
00:07:09,033 --> 00:07:10,600
单单的prompt的输入

225
00:07:10,600 --> 00:07:11,500
或者分身扣

226
00:07:11,533 --> 00:07:13,833
MCP主要是在技术上面

227
00:07:13,833 --> 00:07:15,100
统一了三个标准

228
00:07:15,133 --> 00:07:16,633
第一个就是工具

229
00:07:16,633 --> 00:07:18,233
我们执行的一些工具

230
00:07:18,233 --> 00:07:20,866
API或者数据集的一些访问

231
00:07:20,900 --> 00:07:24,133
都统一好了相关的规定的接口的约束

232
00:07:24,200 --> 00:07:25,800
第二个就是资源

233
00:07:25,800 --> 00:07:28,000
因为你会发现现在的APP的应用

234
00:07:28,000 --> 00:07:29,000
非常的多

235
00:07:29,000 --> 00:07:30,033
包括文件日志

236
00:07:30,033 --> 00:07:31,566
还有API的调用

237
00:07:31,566 --> 00:07:33,600
所以说我们需要对数据的流

238
00:07:33,600 --> 00:07:34,766
就是data streams

239
00:07:34,766 --> 00:07:36,866
进行一个结构化的构造

240
00:07:36,900 --> 00:07:38,733
这样的话会方便大模型

241
00:07:38,733 --> 00:07:39,800
进行一个调度

242
00:07:39,800 --> 00:07:41,433
或者大模型后面的MCP

243
00:07:41,433 --> 00:07:42,800
进行一个执行

244
00:07:42,833 --> 00:07:44,600
那第三个结构化的内容

245
00:07:44,600 --> 00:07:46,033
就是所谓的prompt了

246
00:07:46,033 --> 00:07:48,666
因为世界上面prompt千千万

247
00:07:48,700 --> 00:07:50,900
我们可以看到前两年招人

248
00:07:50,900 --> 00:07:52,333
或者很多公司招聘

249
00:07:52,333 --> 00:07:54,166
都会招一些prompt的工程师

250
00:07:54,166 --> 00:07:56,300
然后你会发现现在的prompt的工程师

251
00:07:56,333 --> 00:07:57,966
基本上也很少再招了

252
00:07:57,966 --> 00:07:59,233
也没有太多的作用

253
00:07:59,233 --> 00:08:00,200
但是这里面

254
00:08:00,200 --> 00:08:01,466
因为经过好几年了

255
00:08:01,500 --> 00:08:03,600
大模型两年的一个发展

256
00:08:03,600 --> 00:08:05,000
我们现在对prompt的认知

257
00:08:05,000 --> 00:08:06,500
也非常的充分了

258
00:08:06,533 --> 00:08:07,200
所以这里面

259
00:08:07,200 --> 00:08:07,833
对prompt

260
00:08:07,833 --> 00:08:10,500
也需要进行一个结构化

261
00:08:10,533 --> 00:08:12,933
让我们很多的模板出来

262
00:08:12,933 --> 00:08:14,900
也就是提供很多的instruct prompt

263
00:08:14,900 --> 00:08:17,000
或者instruct的一个template

264
00:08:17,000 --> 00:08:18,066
instruction的模板

265
00:08:18,100 --> 00:08:19,033
指令的模板

266
00:08:19,033 --> 00:08:20,500
让我们很多的工作流

267
00:08:20,533 --> 00:08:21,900
或者工作的一个内容

268
00:08:21,900 --> 00:08:24,133
或者我们对应的上下文

269
00:08:24,133 --> 00:08:26,933
能够有非常结构化的清晰的内容

270
00:08:26,933 --> 00:08:29,500
所以说这里面整合了三个内容

271
00:08:30,166 --> 00:08:32,800
我们重点的来看看右边的这个图

272
00:08:32,800 --> 00:08:34,233
那左边的这个client

273
00:08:34,233 --> 00:08:35,500
就是我们对应的host

274
00:08:35,533 --> 00:08:38,533
一个对应的大模型的APP

275
00:08:38,533 --> 00:08:39,400
每一个client

276
00:08:39,400 --> 00:08:41,466
都会跟一个server

277
00:08:41,500 --> 00:08:43,500
进行一对一的配比

278
00:08:43,500 --> 00:08:45,433
有了MCP的server之后

279
00:08:45,533 --> 00:08:47,600
server规定好了所有的东西

280
00:08:47,600 --> 00:08:49,100
规定好我们刚才讲到的一个tools

281
00:08:49,133 --> 00:08:50,500
有多少个工具

282
00:08:50,500 --> 00:08:51,566
有多少资源

283
00:08:51,566 --> 00:08:52,300
有多少prompt

284
00:08:52,333 --> 00:08:52,833
我们prompt

285
00:08:52,833 --> 00:08:54,233
一定要规范化

286
00:08:54,233 --> 00:08:57,466
然后一些应用data resource

287
00:08:57,466 --> 00:09:00,133
就会传给MCP server

288
00:09:00,200 --> 00:09:01,600
按照这些tools

289
00:09:01,833 --> 00:09:04,233
resource prompt的相关结构化的内容

290
00:09:04,233 --> 00:09:08,433
对APP提供相关的服务

291
00:09:08,433 --> 00:09:10,566
那整体来说比较简单

292
00:09:10,566 --> 00:09:10,866
但是

293
00:09:10,900 --> 00:09:12,933
我们值得注意的就是它其实

294
00:09:12,933 --> 00:09:16,133
提供一个本地的一个安全的security

295
00:09:16,133 --> 00:09:18,233
就为什么它的一个传输的方式

296
00:09:18,233 --> 00:09:20,266
特别是中间的transport layer

297
00:09:20,300 --> 00:09:22,533
实际上有两种的传输的方式

298
00:09:22,833 --> 00:09:24,233
一种就是STDIO

299
00:09:24,233 --> 00:09:27,166
stander IO保证本地的安全性

300
00:09:27,166 --> 00:09:27,966
那另外一种

301
00:09:27,966 --> 00:09:30,000
就是一个网络的连接

302
00:09:30,000 --> 00:09:31,433
通过SSE

303
00:09:31,433 --> 00:09:34,366
进行一个网络的传输的链接

304
00:09:34,400 --> 00:09:35,633
那本地的访问

305
00:09:35,633 --> 00:09:37,600
就是为了保证大模型

306
00:09:37,600 --> 00:09:39,833
对私有数据的一个保密性

307
00:09:39,833 --> 00:09:40,633
那当然

308
00:09:40,633 --> 00:09:41,566
MCP默认

309
00:09:41,566 --> 00:09:44,800
是在一个本地端去执行

310
00:09:44,800 --> 00:09:45,500
除非特殊

311
00:09:45,533 --> 00:09:48,000
是声明对网络进行访问链接

312
00:09:48,000 --> 00:09:50,566
否则我们还是推荐使用第一个

313
00:09:50,566 --> 00:09:52,000
就是local file system

314
00:09:52,000 --> 00:09:53,566
或者Data base

315
00:09:53,566 --> 00:09:55,600
相关的数据库相关的内容

316
00:09:55,600 --> 00:09:58,000
但是我们发现现在大部分内容

317
00:09:58,000 --> 00:10:00,500
或者我们很多的APP

318
00:10:00,533 --> 00:10:01,700
就未来的形态

319
00:10:01,700 --> 00:10:03,233
可能手机里面

320
00:10:03,233 --> 00:10:05,066
有一个MCP的host

321
00:10:05,200 --> 00:10:07,533
然后会访问很多手机里面的应用

322
00:10:07,533 --> 00:10:10,333
当然当我们假设我们一台手机

323
00:10:10,333 --> 00:10:12,366
要访问京东或者美团

324
00:10:12,366 --> 00:10:14,100
最近打架打的非常厉害

325
00:10:14,133 --> 00:10:16,400
这种b端的APP的时候

326
00:10:16,400 --> 00:10:19,400
有可能就真正的就通过本地的访问

327
00:10:19,400 --> 00:10:21,000
然后b端的APP

328
00:10:21,000 --> 00:10:23,866
再通过软端的访问进行一个合作

329
00:10:23,900 --> 00:10:24,300
所以说

330
00:10:24,300 --> 00:10:26,766
它是一个合作跟竞争的一个整体

331
00:10:26,766 --> 00:10:28,466
的关系我觉得蛮有意思

332
00:10:28,500 --> 00:10:30,900
就是MCP跟A2A之间

333
00:10:30,900 --> 00:10:34,400
未来会往哪个方向去发展和引进

334
00:10:34,433 --> 00:10:35,600
那我们刚才讲到了

335
00:10:35,600 --> 00:10:38,566
MCP提供了两种的一个传输协议

336
00:10:38,566 --> 00:10:40,000
如果对外提供的服务

337
00:10:40,000 --> 00:10:41,800
就使用SSE

338
00:10:41,800 --> 00:10:43,500
也就是Server-Sent Events

339
00:10:43,533 --> 00:10:45,400
相关的服务的内容

340
00:10:46,166 --> 00:10:46,833
那下面

341
00:10:46,833 --> 00:10:49,466
我们其实可以看到STDIO跟SSE

342
00:10:49,500 --> 00:10:50,833
相关的一个比较

343
00:10:50,833 --> 00:10:51,900
ZOMI不在这里面

344
00:10:51,933 --> 00:10:54,766
进行过多的详细的讲述了

345
00:10:54,766 --> 00:10:56,366
因为不管是采用哪种方式

346
00:10:56,366 --> 00:10:58,366
基本上已经固定了这个协议

347
00:10:58,366 --> 00:11:01,433
我们遵循这个MCP的协议Protocol

348
00:11:01,433 --> 00:11:03,366
就可以完成相关的内容

349
00:11:03,366 --> 00:11:04,600
那比较有意思

350
00:11:04,600 --> 00:11:06,566
我们这里面做了一个总结

351
00:11:06,566 --> 00:11:09,366
在整个MCP的设计理念里面

352
00:11:09,366 --> 00:11:12,366
有五个比较重要的feature

353
00:11:12,366 --> 00:11:13,166
就是特性了

354
00:11:13,166 --> 00:11:16,066
第一个就是会话的一个状态

355
00:11:16,100 --> 00:11:17,366
因为整个大模型里面

356
00:11:17,366 --> 00:11:19,100
我们是持续性的对话

357
00:11:19,133 --> 00:11:20,166
就我问一个问题

358
00:11:20,166 --> 00:11:21,633
他有可能回答我一个问题

359
00:11:21,633 --> 00:11:22,400
我再问一个问题

360
00:11:22,400 --> 00:11:24,766
他可能帮我执行下一个动作

361
00:11:24,766 --> 00:11:25,433
所以我们这里面

362
00:11:25,433 --> 00:11:28,400
保持一个维护或者那个会话的状态

363
00:11:28,400 --> 00:11:30,633
让server跟client之间

364
00:11:30,633 --> 00:11:32,700
建立一个长期的链接

365
00:11:32,733 --> 00:11:35,366
然后让整个会话有明确的生命周期

366
00:11:35,366 --> 00:11:38,300
可以持续性的去执行一些相关的动作

367
00:11:38,400 --> 00:11:40,633
第二就是双向的通讯

368
00:11:40,633 --> 00:11:41,266
蛮有意思

369
00:11:41,300 --> 00:11:43,433
客户端可以调用服务器

370
00:11:43,433 --> 00:11:45,100
传统RCP那服务器

371
00:11:45,133 --> 00:11:47,200
也同样的可以去调用客户端

372
00:11:47,200 --> 00:11:49,366
去对客户端进行一些通知

373
00:11:49,366 --> 00:11:50,266
我执行完之后

374
00:11:50,300 --> 00:11:52,000
我会告诉你我执行的内容

375
00:11:52,000 --> 00:11:52,833
然后你可以发

376
00:11:52,833 --> 00:11:53,633
送一些任务

377
00:11:53,633 --> 00:11:55,300
告诉我我要执行什么

378
00:11:55,600 --> 00:11:57,933
比较简单的就是标准化的接口了

379
00:11:57,933 --> 00:11:59,233
这个大家都知道了

380
00:11:59,366 --> 00:12:00,466
在整个MCP里面

381
00:12:00,500 --> 00:12:01,700
大模型怎么去调

382
00:12:01,700 --> 00:12:03,133
大模型怎么去使用

383
00:12:03,133 --> 00:12:05,533
肯定是规定了一套标准的操作

384
00:12:05,533 --> 00:12:09,333
例如我们刚才讲到的一个prompt 

385
00:12:09,333 --> 00:12:11,166
大模型主要是输入token

386
00:12:11,166 --> 00:12:11,966
输出token

387
00:12:12,033 --> 00:12:14,033
那输入的token的规则

388
00:12:14,033 --> 00:12:15,033
或者我们那段话

389
00:12:15,033 --> 00:12:16,100
应该怎么组成

390
00:12:16,133 --> 00:12:17,966
主要是由prompt来去实现

391
00:12:18,166 --> 00:12:19,100
而这个prompt

392
00:12:19,133 --> 00:12:21,433
就规定了使用了Json的Schema

393
00:12:21,433 --> 00:12:22,300
Json的格式

394
00:12:22,333 --> 00:12:23,966
去定义参数

395
00:12:23,966 --> 00:12:25,200
还有返回值

396
00:12:25,366 --> 00:12:27,433
保证互操作性

397
00:12:27,433 --> 00:12:30,300
能够大家都有一个统一的标准

398
00:12:30,333 --> 00:12:31,966
那我们在后面

399
00:12:31,966 --> 00:12:33,433
下一个小节的内容里面

400
00:12:33,433 --> 00:12:33,966
打开

401
00:12:33,966 --> 00:12:37,266
就会看到很多代码的prompt都固定好

402
00:12:37,366 --> 00:12:38,500
那第四个

403
00:12:38,533 --> 00:12:39,166
还有第五个

404
00:12:39,166 --> 00:12:40,300
就是能力的协商

405
00:12:40,333 --> 00:12:41,400
就是初级化的阶段

406
00:12:41,400 --> 00:12:42,666
进行能力的协商

407
00:12:42,900 --> 00:12:44,533
动态的就大模型

408
00:12:44,533 --> 00:12:46,400
动态的通过MCP

409
00:12:46,400 --> 00:12:48,566
去发现一些可用的功能

410
00:12:48,566 --> 00:12:49,833
还有不同的版本

411
00:12:49,933 --> 00:12:51,933
那还有一些事件的通知

412
00:12:51,933 --> 00:12:53,333
单向的事件通知

413
00:12:53,366 --> 00:12:55,100
资源的订阅和变更

414
00:12:55,133 --> 00:12:55,933
那4和5

415
00:12:55,933 --> 00:12:57,366
可能是增值功能

416
00:12:57,366 --> 00:13:00,966
123是最重要的一些核心的特性

417
00:13:03,666 --> 00:13:05,166
其实ZOMI讲了很多的废话

418
00:13:05,166 --> 00:13:06,466
现在才来到

419
00:13:06,500 --> 00:13:08,333
ZOMI觉得现在最核心的一个内容

420
00:13:08,333 --> 00:13:09,900
就是模型

421
00:13:09,900 --> 00:13:11,100
大模型是如何确定

422
00:13:11,100 --> 00:13:12,400
怎么去使用工具

423
00:13:12,400 --> 00:13:13,766
怎么通过prompt

424
00:13:13,766 --> 00:13:17,066
通过一些提示词去选用工具

425
00:13:17,100 --> 00:13:18,133
那在这里面

426
00:13:18,133 --> 00:13:20,533
我们正式的去打开这个内容了

427
00:13:20,533 --> 00:13:21,566
那我们刚才讲到了

428
00:13:21,566 --> 00:13:23,800
其实会提出两个疑问

429
00:13:23,800 --> 00:13:24,233
第一个就

430
00:13:24,233 --> 00:13:24,966
是大模型

431
00:13:24,966 --> 00:13:27,433
在什么时候确定使用哪个工具

432
00:13:27,433 --> 00:13:30,766
也就是大模型是怎么去识别工具

433
00:13:30,800 --> 00:13:31,466
第二个问题

434
00:13:31,500 --> 00:13:33,900
就是大模型如何通过MCP

435
00:13:33,900 --> 00:13:35,966
去执行这些工具的任务

436
00:13:35,966 --> 00:13:37,166
也就是怎么识别

437
00:13:37,166 --> 00:13:38,166
怎么去执行

438
00:13:38,166 --> 00:13:39,233
两个话题

439
00:13:39,633 --> 00:13:40,700
带着这两个疑问

440
00:13:40,733 --> 00:13:42,733
我们看一下具体的一个实际的代码

441
00:13:42,733 --> 00:13:44,533
和相关的案例

442
00:13:45,600 --> 00:13:46,633
在这里面

443
00:13:46,633 --> 00:13:47,366
xxxxxx

444
00:13:47,366 --> 00:13:48,466
就为我们提供了一个

445
00:13:48,500 --> 00:13:50,200
非常详细的答案了

446
00:13:50,200 --> 00:13:52,266
那我们简单的去看一下

447
00:13:52,300 --> 00:13:55,000
首先当用户提出一个问题的时候

448
00:13:55,000 --> 00:13:56,100
也就是给大模型

449
00:13:56,133 --> 00:13:57,300
树一个prompt的时候

450
00:13:57,300 --> 00:13:59,333
客户端所谓的client

451
00:13:59,333 --> 00:14:00,400
就是claude Desktop

452
00:14:00,400 --> 00:14:02,033
就会将问题

453
00:14:02,033 --> 00:14:04,766
发给大模型claude这个大模型

454
00:14:04,800 --> 00:14:05,900
claude这个大模型

455
00:14:05,933 --> 00:14:08,733
就去分析可用的工具

456
00:14:08,733 --> 00:14:09,633
那怎么去分析

457
00:14:09,633 --> 00:14:11,300
其实我们会把一些工具

458
00:14:11,333 --> 00:14:13,633
还有问题都变成prompt

459
00:14:13,633 --> 00:14:15,266
一起给到大模型

460
00:14:15,300 --> 00:14:18,600
然后去决定使用哪一个工具

461
00:14:18,600 --> 00:14:20,100
到底是一个还是多个

462
00:14:20,133 --> 00:14:21,600
由大模型来去使用

463
00:14:21,600 --> 00:14:22,266
那第三步

464
00:14:22,300 --> 00:14:23,566
就是客户端

465
00:14:23,566 --> 00:14:27,833
通过MCP的server去执行所对应的工具

466
00:14:27,833 --> 00:14:28,900
那工具执行之后

467
00:14:28,933 --> 00:14:32,100
就会将结果反馈给一个大模型

468
00:14:32,100 --> 00:14:34,233
反馈给大模型之后

469
00:14:34,433 --> 00:14:35,400
就来到了第五步了

470
00:14:35,400 --> 00:14:36,766
整个大模型claude

471
00:14:36,766 --> 00:14:39,200
这个claude其实就是

472
00:14:39,200 --> 00:14:41,200
自己的大模型结合执行的结果

473
00:14:41,200 --> 00:14:43,100
并且构造成最终的prompt

474
00:14:43,133 --> 00:14:45,566
反馈给一个变成NLP

475
00:14:45,566 --> 00:14:46,700
进行一个输出

476
00:14:46,766 --> 00:14:47,900
最终就是第六步了

477
00:14:47,900 --> 00:14:49,800
展示给一些用户看

478
00:14:49,800 --> 00:14:50,966
所以它整体的过程

479
00:14:50,966 --> 00:14:51,966
实际上

480
00:14:51,966 --> 00:14:53,166
是把MCP

481
00:14:53,166 --> 00:14:55,466
跟大模型是相关的一个连接

482
00:14:55,500 --> 00:14:56,566
融合到一起

483
00:14:56,633 --> 00:14:58,100
那我们现在来重点去看看

484
00:14:58,133 --> 00:14:59,566
整一个架构图

485
00:14:59,566 --> 00:15:03,233
那非常感谢last whisper相关提供的内容

486
00:15:03,233 --> 00:15:04,700
首先我们刚才讲到

487
00:15:04,733 --> 00:15:05,766
大语言模型

488
00:15:05,766 --> 00:15:07,366
它接受一个prompt的输入

489
00:15:07,366 --> 00:15:09,100
也就是输入是词元

490
00:15:09,133 --> 00:15:10,433
或者一个问题

491
00:15:10,433 --> 00:15:11,000
那这里面

492
00:15:11,000 --> 00:15:13,066
问题就变成一个message 1

493
00:15:13,133 --> 00:15:15,500
作为我们整个大模型的输入

494
00:15:15,500 --> 00:15:16,933
那输入非常的讲究

495
00:15:16,933 --> 00:15:18,533
首先我们提出的问题

496
00:15:18,533 --> 00:15:20,733
作为一个输入源之一

497
00:15:20,733 --> 00:15:23,933
当然了我们也会把一些MCP的server

498
00:15:23,933 --> 00:15:25,733
相关的一些描述

499
00:15:25,733 --> 00:15:28,933
也就是document string相关的内容

500
00:15:28,966 --> 00:15:31,400
跟User input结合起来

501
00:15:31,400 --> 00:15:33,800
也就是两个prompt加起来

502
00:15:33,800 --> 00:15:34,866
给到message

503
00:15:34,900 --> 00:15:36,500
给到大模型进行输入

504
00:15:36,500 --> 00:15:38,400
所以不要觉得大源模型一开始就懂

505
00:15:38,400 --> 00:15:39,566
我们有多少工具

506
00:15:39,566 --> 00:15:41,433
实际上我们在真正执行之前

507
00:15:41,433 --> 00:15:42,366
是告诉大模型

508
00:15:42,366 --> 00:15:45,066
我们现在有哪些MCP的server

509
00:15:45,200 --> 00:15:47,700
既然我们要加入很多的system prompt

510
00:15:47,700 --> 00:15:50,166
或者MCP Server相关的document string

511
00:15:50,166 --> 00:15:51,266
所以这里面

512
00:15:51,300 --> 00:15:52,333
整个大源模型

513
00:15:52,333 --> 00:15:55,733
就需要接入更长的上下文的文本

514
00:15:55,733 --> 00:15:56,566
告诉这个大模型

515
00:15:56,566 --> 00:15:58,200
我们现在有多少工具

516
00:15:58,200 --> 00:15:59,466
然后我的问题是什么

517
00:15:59,500 --> 00:16:01,700
然后大模型就根据工具

518
00:16:01,700 --> 00:16:03,233
或者根据一个问题

519
00:16:03,233 --> 00:16:06,066
进行一个后调和微训练

520
00:16:06,400 --> 00:16:07,200
然后这个大模型

521
00:16:07,200 --> 00:16:08,766
就是让我们针对这个message

522
00:16:08,766 --> 00:16:10,100
是怎么去响应

523
00:16:10,133 --> 00:16:10,900
那响应的过程

524
00:16:10,900 --> 00:16:12,933
就是我们刚才讲到的那几个了

525
00:16:12,933 --> 00:16:14,400
我们去调用工具

526
00:16:14,400 --> 00:16:15,266
调用完工具之后

527
00:16:15,300 --> 00:16:16,300
反馈结果

528
00:16:16,300 --> 00:16:17,333
那反馈结果

529
00:16:17,333 --> 00:16:19,033
因为我们线下的大模型

530
00:16:19,033 --> 00:16:20,900
能够支持长对话

531
00:16:20,933 --> 00:16:22,766
那这里面就变成对话 一

532
00:16:22,766 --> 00:16:24,433
这里面就变成对话 二

533
00:16:24,433 --> 00:16:26,366
把结果反馈回来

534
00:16:26,366 --> 00:16:29,633
然后就进行下一轮的对话

535
00:16:29,633 --> 00:16:30,366
这种方式

536
00:16:30,366 --> 00:16:33,033
来去实现或者执行我们整个MCP

537
00:16:33,033 --> 00:16:33,766
所以ZOMI觉得

538
00:16:33,766 --> 00:16:35,600
这个图画的非常的好

539
00:16:35,600 --> 00:16:36,100
同样

540
00:16:36,133 --> 00:16:39,600
我们再次感谢last whisper相关的小伙伴

541
00:16:40,333 --> 00:16:40,966
那么这里面

542
00:16:40,966 --> 00:16:43,066
通过三个点跟大家去呈现

543
00:16:43,100 --> 00:16:44,333
第一个点就是大模型

544
00:16:44,333 --> 00:16:45,300
通过一个prompt

545
00:16:45,300 --> 00:16:47,166
来确定我们当前使用哪个工具

546
00:16:47,166 --> 00:16:49,266
接着由大模型的输出

547
00:16:49,300 --> 00:16:52,600
output来确定使用哪些MCP的server

548
00:16:53,033 --> 00:16:55,633
之后MCP的client的host端

549
00:16:55,633 --> 00:16:57,700
就会执行对应的MCP的server

550
00:16:57,733 --> 00:16:58,733
并且

551
00:16:58,733 --> 00:17:00,166
把对应执行的结果

552
00:17:00,166 --> 00:17:01,800
反馈给大模型

553
00:17:01,800 --> 00:17:04,300
大模型把这个结果合并起来

554
00:17:04,333 --> 00:17:06,100
再进行进一轮的对话

555
00:17:06,100 --> 00:17:07,766
最后进行一个输出

556
00:17:07,766 --> 00:17:10,166
给到一个人去看

557
00:17:10,166 --> 00:17:11,900
那一共就这么三步

558
00:17:11,933 --> 00:17:12,800
比较简单

559
00:17:12,800 --> 00:17:14,400
那我们现在逐步的去打开

560
00:17:14,400 --> 00:17:15,966
第一步就是prompt

561
00:17:15,966 --> 00:17:17,166
我们大模型

562
00:17:17,166 --> 00:17:19,466
通过prompt来了解当前有哪些工具

563
00:17:19,500 --> 00:17:20,966
也就是把一些工具

564
00:17:20,966 --> 00:17:23,300
跟一个问题结合起来

565
00:17:23,633 --> 00:17:25,066
具体是通过描述

566
00:17:25,100 --> 00:17:26,100
以文本的形式

567
00:17:26,100 --> 00:17:27,600
传递给大模型

568
00:17:27,600 --> 00:17:28,766
然后供大模型

569
00:17:28,766 --> 00:17:29,833
了解有哪些工具

570
00:17:29,833 --> 00:17:30,666
进行选择

571
00:17:30,700 --> 00:17:31,733
我们现在就打开

572
00:17:31,733 --> 00:17:33,833
具体的一个server的代码

573
00:17:34,666 --> 00:17:38,400
我们现在来打开一个MCP里面

574
00:17:38,400 --> 00:17:39,800
一个Python SDK里面

575
00:17:39,800 --> 00:17:41,866
一个简单的chatbox的一个demo

576
00:17:41,900 --> 00:17:43,533
也就是对话机器人

577
00:17:43,533 --> 00:17:44,133
那这里面

578
00:17:44,133 --> 00:17:46,633
有一个对应的server已经写好了

579
00:17:46,633 --> 00:17:47,066
很重要

580
00:17:47,100 --> 00:17:50,033
我们看一下里面的一个内容叫做start

581
00:17:50,033 --> 00:17:51,433
那在这start里面

582
00:17:51,433 --> 00:17:54,400
主要是我们整个client的一个起始了

583
00:17:54,400 --> 00:17:54,866
那上面

584
00:17:54,900 --> 00:17:56,933
我们省略了很多没有关系的代码

585
00:17:56,933 --> 00:17:57,433
那这里面

586
00:17:57,433 --> 00:17:58,233
很重要的就是

587
00:17:58,233 --> 00:17:59,400
首先第一步

588
00:17:59,400 --> 00:18:01,500
就是for server in self . servers

589
00:18:01,966 --> 00:18:04,066
也就是初始化所有的MCP的server

590
00:18:04,533 --> 00:18:07,100
然后通过命令行

591
00:18:07,100 --> 00:18:08,800
就是for server in self . servers

592
00:18:08,800 --> 00:18:09,766
通过命令行

593
00:18:09,766 --> 00:18:11,266
获得所有的工具

594
00:18:11,300 --> 00:18:11,966
也有tools

595
00:18:11,966 --> 00:18:13,766
所有的工具的一个列表

596
00:18:13,766 --> 00:18:14,833
把所有的工具

597
00:18:14,833 --> 00:18:17,966
通过all_tools.extend 把所有的工具都拿出来

598
00:18:18,200 --> 00:18:19,966
我们看到第356行

599
00:18:19,966 --> 00:18:22,566
是获得所有的tools的功能描述的格式化

600
00:18:22,566 --> 00:18:23,800
成字符串

601
00:18:23,800 --> 00:18:25,866
提供给大模型去使用

602
00:18:25,900 --> 00:18:26,633
那这里面

603
00:18:26,633 --> 00:18:27,666
我们要注意一下

604
00:18:27,700 --> 00:18:30,166
就是tools.format_for_llm

605
00:18:30,166 --> 00:18:30,700
那这里面

606
00:18:30,733 --> 00:18:31,800
放到这一段代码

607
00:18:31,800 --> 00:18:33,200
其实是方便我们整体

608
00:18:33,200 --> 00:18:34,633
去把所有的东西

609
00:18:34,633 --> 00:18:35,633
或者把刚才

610
00:18:35,633 --> 00:18:37,666
所有的tools描述

611
00:18:37,700 --> 00:18:39,700
变成一个具体的string

612
00:18:39,700 --> 00:18:40,166
那这里面

613
00:18:40,166 --> 00:18:42,233
我们可以看到有一个system message

614
00:18:42,233 --> 00:18:44,600
也就是对应的358行代码

615
00:18:44,600 --> 00:18:46,266
这里面的这个代码大家一看

616
00:18:46,300 --> 00:18:47,433
就很明确了

617
00:18:47,433 --> 00:18:47,900
这里面

618
00:18:47,933 --> 00:18:49,433
就不再简化了

619
00:18:49,633 --> 00:18:50,233
实际上

620
00:18:50,233 --> 00:18:51,666
就是基于所有的  prompt

621
00:18:51,700 --> 00:18:52,800
现在的所有的  prompt

622
00:18:53,033 --> 00:18:54,566
给到我们整个工具

623
00:18:54,566 --> 00:18:55,633
给到大模型

624
00:18:55,633 --> 00:18:57,266
去感知告诉我们

625
00:18:57,300 --> 00:18:58,700
我们现在的  prompt是什么

626
00:18:58,700 --> 00:19:00,100
我们现在tools是什么

627
00:19:00,100 --> 00:19:01,166
最后把所有东西

628
00:19:01,166 --> 00:19:02,600
都变成一个message

629
00:19:02,600 --> 00:19:04,500
进行一个输出

630
00:19:04,733 --> 00:19:05,366
那我们看一下

631
00:19:05,366 --> 00:19:06,766
这里面有一个while true

632
00:19:06,766 --> 00:19:08,766
在第382行

633
00:19:08,766 --> 00:19:09,166
这里面

634
00:19:09,166 --> 00:19:11,833
假设已经使用了用户的一个消息

635
00:19:11,833 --> 00:19:12,833
作为输入了

636
00:19:12,833 --> 00:19:14,833
那所以我们这里面有一个iMPUt

637
00:19:14,833 --> 00:19:16,433
输入

638
00:19:16,433 --> 00:19:18,300
把message了append起来

639
00:19:18,333 --> 00:19:19,533
要把用户的输入

640
00:19:19,533 --> 00:19:22,500
跟我们所有的工具的prompt组

641
00:19:22,500 --> 00:19:23,833
支持来的一个prompt

642
00:19:23,833 --> 00:19:25,233
进行一个结合

643
00:19:25,233 --> 00:19:25,666
因此

644
00:19:25,700 --> 00:19:27,833
就变成我们最终的一个message了

645
00:19:27,833 --> 00:19:28,366
那接着

646
00:19:28,366 --> 00:19:29,900
我们会把这个message

647
00:19:29,933 --> 00:19:33,200
跟用户的消息一起打包在一起

648
00:19:33,200 --> 00:19:34,966
变成391行

649
00:19:34,966 --> 00:19:37,900
大家一起发给大语言模型

650
00:19:37,933 --> 00:19:40,033
LLM了那后面的这些

651
00:19:40,033 --> 00:19:42,300
跟使用哪个工具就没有关系了

652
00:19:42,333 --> 00:19:44,100
那我们回到PPT里面

653
00:19:44,100 --> 00:19:47,166
看到刚才去解读的那段代码

654
00:19:47,166 --> 00:19:49,666
就是我们整个架构图里面

655
00:19:49,700 --> 00:19:51,166
对应的这一段

656
00:19:51,166 --> 00:19:51,966
server

657
00:19:51,966 --> 00:19:53,366
把用户的User input

658
00:19:53,366 --> 00:19:56,100
跟一些所有的工具的prompt

659
00:19:56,300 --> 00:19:57,100
结合起来

660
00:19:57,100 --> 00:19:59,366
然后丢给大模型作为输入

661
00:19:59,366 --> 00:20:01,266
我们刚看完第一个内容

662
00:20:01,300 --> 00:20:04,033
怎么给到大语言模型进行输入

663
00:20:04,900 --> 00:20:05,733
那提到这一点

664
00:20:05,733 --> 00:20:06,766
ZOMI就不得不说

665
00:20:06,766 --> 00:20:08,566
实际上我们有很多的prompt嘛

666
00:20:08,566 --> 00:20:09,500
还有里面的内容

667
00:20:09,533 --> 00:20:11,533
其实都是MCP里面写好

668
00:20:11,533 --> 00:20:12,533
那为什么claude

669
00:20:12,533 --> 00:20:14,000
就调用这些工具的时候

670
00:20:14,000 --> 00:20:15,900
特别的可能比其他大模型更好

671
00:20:15,933 --> 00:20:17,766
是因为ZOMI严重的怀疑

672
00:20:17,766 --> 00:20:19,066
claude对这里面的prompt

673
00:20:19,100 --> 00:20:21,533
和对应的那个MCP的string

674
00:20:21,533 --> 00:20:23,033
做了一个特殊的后训练

675
00:20:23,033 --> 00:20:24,666
或者一个微调

676
00:20:24,900 --> 00:20:26,300
让整个claude这个模型

677
00:20:26,300 --> 00:20:27,300
更好的去理解

678
00:20:27,300 --> 00:20:30,000
我们这些工具的对应的prompt

679
00:20:30,100 --> 00:20:31,300
跟结构化的输出

680
00:20:31,300 --> 00:20:32,333
因为结构化的输出

681
00:20:32,333 --> 00:20:34,600
这里面的输出是对应的json

682
00:20:34,600 --> 00:20:36,400
给到json文件进行输出

683
00:20:36,400 --> 00:20:37,700
有了json的文件之后

684
00:20:37,733 --> 00:20:39,233
我们就真正的给到MCP

685
00:20:39,233 --> 00:20:41,166
server去一个执行

686
00:20:41,166 --> 00:20:43,600
所以说第一轮输入的是一个prompt

687
00:20:43,600 --> 00:20:47,200
它输出是一个对应的json的格式

688
00:20:49,033 --> 00:20:50,766
那第二步就比较简单

689
00:20:50,766 --> 00:20:51,400
整个大模型

690
00:20:51,400 --> 00:20:52,366
通过prompt

691
00:20:52,366 --> 00:20:54,566
也就提供的工具给格式化的描述

692
00:20:54,566 --> 00:20:56,433
通过few-shot的example

693
00:20:56,433 --> 00:20:59,233
作为输入来确定使用哪些工具

694
00:20:59,300 --> 00:21:01,433
输出就是已经few-shot好

695
00:21:01,433 --> 00:21:02,900
或者我们已经微调好

696
00:21:02,933 --> 00:21:05,600
一个具体的json格式了

697
00:21:05,600 --> 00:21:07,600
那我们现在来到了第三步

698
00:21:07,600 --> 00:21:08,900
重点去看一下这个内容

699
00:21:08,933 --> 00:21:10,800
工具的执行和结果的反馈

700
00:21:10,800 --> 00:21:12,400
就对应的怎么去执行

701
00:21:12,600 --> 00:21:13,866
那大模型

702
00:21:13,900 --> 00:21:15,200
实际上这一步比较简单

703
00:21:15,200 --> 00:21:17,100
从在下一步把system的prompt

704
00:21:17,133 --> 00:21:19,233
就跟用户的消息一起发送给大模型

705
00:21:19,500 --> 00:21:21,600
然后接受模型的回复

706
00:21:21,600 --> 00:21:23,433
当模型的分析用户的请求之后

707
00:21:23,433 --> 00:21:26,800
就会决定我们要调用哪些工具了

708
00:21:26,800 --> 00:21:28,066
当没有工具调用的时候

709
00:21:28,100 --> 00:21:30,566
模型就直接生成自然语言的一个回复

710
00:21:30,566 --> 00:21:32,400
就是NLP的回复

711
00:21:32,400 --> 00:21:32,666
当然

712
00:21:32,700 --> 00:21:35,400
当我们检测到有工具去执行的时候

713
00:21:35,533 --> 00:21:38,133
模型就会输出结构化的JSON的格式

714
00:21:38,133 --> 00:21:40,333
然后去调用请求

715
00:21:40,333 --> 00:21:40,900
那这里面

716
00:21:40,900 --> 00:21:44,133
我们同样的去看回对应的代码

717
00:21:45,033 --> 00:21:46,700
我们现在来到了具体的代码

718
00:21:46,733 --> 00:21:48,166
看一下394行

719
00:21:48,166 --> 00:21:51,033
同样还是刚才的一个chatbot相关的内容

720
00:21:51,033 --> 00:21:52,500
那在394行里面

721
00:21:52,533 --> 00:21:55,566
就有了一个await self. process_llm_response

722
00:21:55,566 --> 00:21:58,000
把大语言模型跟刚才的一些

723
00:21:58,000 --> 00:21:59,300
工具

724
00:21:59,333 --> 00:22:00,833
所谓的工具的一个string

725
00:22:00,833 --> 00:22:02,966
输给大模型进行处理

726
00:22:02,966 --> 00:22:04,033
那大模型我们现在

727
00:22:04,033 --> 00:22:05,266
就进入了这个函数

728
00:22:05,300 --> 00:22:06,700
具体的去看一下

729
00:22:06,733 --> 00:22:09,733
里面是296行

730
00:22:09,733 --> 00:22:11,200
有一个def process

731
00:22:11,933 --> 00:22:13,200
一个llm response

732
00:22:13,200 --> 00:22:13,700
那这里面

733
00:22:13,733 --> 00:22:15,966
就真正的去处理一个内容了

734
00:22:15,966 --> 00:22:16,866
去执行

735
00:22:16,900 --> 00:22:19,733
我们往下看一下下面的一段代码

736
00:22:20,800 --> 00:22:22,700
这里面有非常多的东西

737
00:22:22,733 --> 00:22:24,600
就把LM的response

738
00:22:24,600 --> 00:22:27,700
给一个json格式的去一个解析

739
00:22:27,733 --> 00:22:29,300
如果解析到json格式

740
00:22:29,300 --> 00:22:30,766
就返回一个

741
00:22:31,033 --> 00:22:32,166
直接的一个response

742
00:22:32,166 --> 00:22:32,700
返回处

743
00:22:32,733 --> 00:22:35,333
如果否则的话就会遇到一个error

744
00:22:35,333 --> 00:22:36,033
那这种方式

745
00:22:36,033 --> 00:22:38,400
就主要还是对一个json的格式

746
00:22:38,400 --> 00:22:39,666
或者我们大模型

747
00:22:39,966 --> 00:22:40,466
在这里面

748
00:22:40,500 --> 00:22:43,966
去判断我们是否有工具需要去调用

749
00:22:44,800 --> 00:22:47,166
我们现在来跳出process llm response 

750
00:22:47,166 --> 00:22:49,633
看一下上面的这个start的一个代码

751
00:22:49,633 --> 00:22:51,833
也是对应的刚才讲到

752
00:22:51,833 --> 00:22:53,066
已经讲完这一段了

753
00:22:53,100 --> 00:22:54,733
我们继续往下看

754
00:22:54,733 --> 00:22:55,333
那这里面

755
00:22:55,333 --> 00:22:57,233
我们注意一下396行

756
00:22:57,233 --> 00:23:00,300
这里面if result不等于LLM respond

757
00:23:00,333 --> 00:23:02,033
那这句话就说明了

758
00:23:02,033 --> 00:23:04,266
如果result跟LLM respond不同

759
00:23:04,300 --> 00:23:06,800
就说明执行了太多的tool call

760
00:23:06,800 --> 00:23:09,133
如果将这些tool call的结果

761
00:23:09,133 --> 00:23:10,966
重新发送给一个大模型

762
00:23:10,966 --> 00:23:12,500
进行一个处理

763
00:23:12,533 --> 00:23:14,200
那这里面有一个else

764
00:23:14,200 --> 00:23:15,233
否则的话

765
00:23:15,233 --> 00:23:17,100
我们就代表没有执行tool call

766
00:23:17,133 --> 00:23:19,600
那我们直接将LLM的一个输出

767
00:23:19,600 --> 00:23:21,466
返回给用户

768
00:23:22,966 --> 00:23:24,266
因此我们第二步

769
00:23:24,300 --> 00:23:27,233
主要围绕着394行跟一个407行

770
00:23:27,233 --> 00:23:30,600
当然大家也可以打开394行的一个process

771
00:23:30,600 --> 00:23:32,200
LLM response来看

772
00:23:32,433 --> 00:23:33,600
这里面的工具的文档

773
00:23:33,600 --> 00:23:35,600
可以看到至关的重要

774
00:23:35,600 --> 00:23:37,266
模型通过工具描述文本

775
00:23:37,300 --> 00:23:38,966
来理解和选择对应的工具

776
00:23:38,966 --> 00:23:39,300
因此

777
00:23:39,333 --> 00:23:41,500
我们需要精心的编排工具的名称

778
00:23:41,500 --> 00:23:43,366
document string和相关的参数

779
00:23:43,366 --> 00:23:44,166
至关重要

780
00:23:44,166 --> 00:23:44,433
也就是

781
00:23:44,433 --> 00:23:47,066
怎么去把一个所谓的工具

782
00:23:47,100 --> 00:23:49,600
结合这个MCP的prompt

783
00:23:49,733 --> 00:23:51,533
更好的一个合并

784
00:23:51,533 --> 00:23:53,700
那由于MCP的选择是基于prompt

785
00:23:53,700 --> 00:23:55,700
所以说提供任何模型

786
00:23:55,700 --> 00:23:57,800
其实都是适配于MCP

787
00:23:57,800 --> 00:24:00,633
我们只需要提供对应的工具的描述

788
00:24:00,633 --> 00:24:02,866
tool的描述就可以了

789
00:24:02,900 --> 00:24:04,900
那我们现在回到整体的PPT

790
00:24:04,966 --> 00:24:06,800
我们粗略的了解完了整个大模型

791
00:24:06,800 --> 00:24:09,600
是怎么去跟MCP进行一个协作

792
00:24:09,600 --> 00:24:12,266
我们现在来到最后一个内容

793
00:24:13,200 --> 00:24:16,100
也就是所谓的总结和思考了

794
00:24:16,400 --> 00:24:17,766
在总结思考这个环节

795
00:24:17,766 --> 00:24:19,366
我们可能简单的过一过

796
00:24:19,366 --> 00:24:21,100
就是整个MCP的一个本质

797
00:24:21,133 --> 00:24:22,800
就是统一的一个协议的标准

798
00:24:22,800 --> 00:24:23,800
使得大模型

799
00:24:23,800 --> 00:24:25,566
能够以一致的方式

800
00:24:25,600 --> 00:24:26,833
跟各种各样的工具

801
00:24:26,833 --> 00:24:29,466
或者数据源进行一个结合

802
00:24:29,866 --> 00:24:30,600
讲完本质之后

803
00:24:30,600 --> 00:24:31,700
我们看一下它的价值

804
00:24:31,733 --> 00:24:33,300
主要是解决传统function 

805
00:24:33,300 --> 00:24:34,833
call相关的依赖问题

806
00:24:34,833 --> 00:24:36,833
提供一个更加方便的一个接口

807
00:24:36,833 --> 00:24:39,366
加快了我们整个AI Agent落地的程度

808
00:24:39,366 --> 00:24:40,200
让很多的应用

809
00:24:40,200 --> 00:24:42,833
能快速接近一个大模型

810
00:24:43,166 --> 00:24:44,733
那整体的使用和开发

811
00:24:44,733 --> 00:24:46,200
对于普通的开发者来说

812
00:24:46,200 --> 00:24:48,600
MCP提供非常丰富的现场的工具

813
00:24:48,600 --> 00:24:50,766
所以说MCP已经提供了很多server了

814
00:24:50,766 --> 00:24:52,933
所以我们可以在不了解技术的情况下

815
00:24:52,933 --> 00:24:55,033
去调用server就调API就行了

816
00:24:55,033 --> 00:24:57,233
我们变成调包侠就好了

817
00:24:57,233 --> 00:24:59,700
Java的开发者其实非常的友好

818
00:24:59,733 --> 00:25:01,533
那对于一些深入的开发者来说

819
00:25:01,533 --> 00:25:02,766
我们其实整个MCP

820
00:25:02,766 --> 00:25:04,300
提供非常清晰的架构

821
00:25:04,333 --> 00:25:05,633
我们刚才讲到架构

822
00:25:05,633 --> 00:25:07,600
直接提供对应的server就可以了

823
00:25:07,600 --> 00:25:10,366
让整个AI变得更加简单

824
00:25:10,433 --> 00:25:12,433
那技术的关键节点

825
00:25:12,433 --> 00:25:14,200
也就这么几个了

826
00:25:14,200 --> 00:25:15,500
采用了CS的架构

827
00:25:15,533 --> 00:25:16,366
我们刚才讲到了

828
00:25:16,366 --> 00:25:19,100
不是HCS而是真的CS

829
00:25:19,133 --> 00:25:21,133
而且有一个双向的状态

830
00:25:21,133 --> 00:25:21,933
双向的RPC

831
00:25:21,933 --> 00:25:24,433
能够互相的一个事件的驱动

832
00:25:24,433 --> 00:25:25,033
那还有

833
00:25:25,033 --> 00:25:26,966
提供一些非常标准化的一些工具

834
00:25:26,966 --> 00:25:29,366
我们刚才看到了非常标准化的prompt

835
00:25:29,366 --> 00:25:31,066
给到document string

836
00:25:31,400 --> 00:25:32,566
给到一个prompt

837
00:25:32,566 --> 00:25:34,633
然后再结合一个问题

838
00:25:34,633 --> 00:25:35,900
给到大模型

839
00:25:35,933 --> 00:25:38,933
那相比其他的一个MQ

840
00:25:38,933 --> 00:25:41,033
信息的对列API

841
00:25:41,033 --> 00:25:42,000
相关的内容

842
00:25:42,000 --> 00:25:43,866
整体为AI应用

843
00:25:43,900 --> 00:25:46,933
其实更好的提供了一套标准的接口

844
00:25:46,933 --> 00:25:48,233
和服务化的内容

845
00:25:48,733 --> 00:25:50,366
但是我们之前也讲到了

846
00:25:50,366 --> 00:25:52,566
整个MCP的局限性也比较强

847
00:25:52,566 --> 00:25:54,900
因为在整个大语言模型里面

848
00:25:54,933 --> 00:25:56,433
我们主要是通过prompt

849
00:25:56,500 --> 00:25:57,433
也就是文本

850
00:25:57,433 --> 00:25:58,966
来去理解选择的工具

851
00:25:58,966 --> 00:26:00,866
因此需要精心的去编写

852
00:26:00,933 --> 00:26:03,000
对应的一个工具的名称

853
00:26:03,000 --> 00:26:04,800
document steam和相关的参数

854
00:26:04,800 --> 00:26:07,266
反正写好prompt很重要

855
00:26:07,633 --> 00:26:08,233
那第二个

856
00:26:08,233 --> 00:26:09,833
就是工具的使用和理解

857
00:26:09,833 --> 00:26:12,233
实际上是严重依赖于大语言模型

858
00:26:12,233 --> 00:26:13,666
一个基础能力

859
00:26:13,700 --> 00:26:15,300
的就是基模的能力好

860
00:26:15,300 --> 00:26:17,066
工具就执行的好

861
00:26:17,066 --> 00:26:18,233
基模能力不行

862
00:26:18,233 --> 00:26:19,866
工具就执行的不行

863
00:26:19,900 --> 00:26:21,166
所以工具的数量

864
00:26:21,166 --> 00:26:22,033
这是第一个

865
00:26:22,033 --> 00:26:22,500
第二个

866
00:26:22,533 --> 00:26:23,800
就工具的数量

867
00:26:23,800 --> 00:26:26,600
严重异样于LLM的上下长文本

868
00:26:26,600 --> 00:26:28,100
因为我们刚才了解到

869
00:26:28,133 --> 00:26:30,566
每一个工具都有自己的document steam

870
00:26:30,933 --> 00:26:32,566
那每个工具都有自己的document steam

871
00:26:32,566 --> 00:26:35,166
如果我有10个工具就有10个document steam

872
00:26:35,233 --> 00:26:36,666
也就是对应的我们这里面代码

873
00:26:36,700 --> 00:26:40,333
我们有10段这种很复杂的一个prompt

874
00:26:40,400 --> 00:26:41,666
因此我们可以看到

875
00:26:41,700 --> 00:26:43,300
工具的数量越多

876
00:26:43,300 --> 00:26:45,566
我们给到大模型的长下下文本

877
00:26:45,566 --> 00:26:46,833
就越多所以

878
00:26:46,833 --> 00:26:49,400
就越考究模型的记忆能力了

879
00:26:49,566 --> 00:26:50,100
那第三个

880
00:26:50,133 --> 00:26:51,333
就是每一次调用模型

881
00:26:51,333 --> 00:26:54,366
我们只能选中有限的一个工具

882
00:26:54,366 --> 00:26:55,966
不能把我们千千万个

883
00:26:55,966 --> 00:26:58,466
可能10万个工具都丢给大模型

884
00:26:58,500 --> 00:27:01,033
因为长上下文文本是有限

885
00:27:01,033 --> 00:27:03,500
因此不能做到真正的智能

886
00:27:03,533 --> 00:27:04,933
那我们预期未来

887
00:27:04,933 --> 00:27:06,900
随着大模型的基础能力的提升

888
00:27:06,900 --> 00:27:09,533
有可能MCP就被替换掉

889
00:27:09,633 --> 00:27:12,766
或者被大模型给融合进去

890
00:27:12,766 --> 00:27:14,600
我总比觉得融合进去MCP

891
00:27:14,600 --> 00:27:16,666
融合到大模型的训练的过程当中

892
00:27:16,700 --> 00:27:18,300
可能更可能

893
00:27:18,300 --> 00:27:20,233
更有科学的依据

894
00:27:20,233 --> 00:27:22,000
因此MCP现在

895
00:27:22,000 --> 00:27:24,900
有点类似于外挂的形式

896
00:27:24,933 --> 00:27:25,933
那最终

897
00:27:25,933 --> 00:27:29,500
我们就做一个简单的总结或者思考了

898
00:27:29,500 --> 00:27:31,533
就我们上一节已经抛出来了

899
00:27:31,533 --> 00:27:32,966
就是其他的AI模型

900
00:27:32,966 --> 00:27:35,666
也会对MCP相关的prompt

901
00:27:35,700 --> 00:27:37,300
进行后训练和微调

902
00:27:37,300 --> 00:27:39,633
才能够使得MCP

903
00:27:39,633 --> 00:27:40,500
更好的结合到我们

904
00:27:40,533 --> 00:27:41,533
其他大模型

905
00:27:41,533 --> 00:27:43,400
那刚才讲到的MCP的能力

906
00:27:43,400 --> 00:27:44,433
未来ZOMI觉得

907
00:27:44,433 --> 00:27:45,866
可能会集成到

908
00:27:45,900 --> 00:27:48,833
整个模型的训练的环节里面

909
00:27:48,833 --> 00:27:50,866
所以说整体来看

910
00:27:50,900 --> 00:27:52,800
初看MCP是个协议

911
00:27:52,800 --> 00:27:53,600
二看MCP

912
00:27:53,600 --> 00:27:55,000
ZOMI觉得是个工具

913
00:27:55,000 --> 00:27:56,600
第三看MCP

914
00:27:56,600 --> 00:27:58,466
ZOMI还是没有那么的积极

915
00:27:58,500 --> 00:27:59,033
觉得是什么

916
00:27:59,033 --> 00:28:00,433
争夺AI应用的入口

917
00:28:00,433 --> 00:28:01,833
我觉得AI应用的入口

918
00:28:01,833 --> 00:28:04,433
还得看模型的基础能力

919
00:28:04,433 --> 00:28:07,066
把MCP融合进去大模型

920
00:28:07,100 --> 00:28:08,100
真正的去提升

921
00:28:08,100 --> 00:28:10,766
大模型的一个工具的执行的能力

922
00:28:10,766 --> 00:28:12,200
代码的生成能力

923
00:28:12,200 --> 00:28:13,666
和我们JSON string

924
00:28:13,700 --> 00:28:16,833
我们MCP的工具的执行的能力

925
00:28:16,833 --> 00:28:17,700
那今天的内容

926
00:28:17,733 --> 00:28:18,433
就到这里为止

927
00:28:18,433 --> 00:28:19,000
谢谢各位

928
00:28:19,000 --> 00:28:20,200
拜了个拜

